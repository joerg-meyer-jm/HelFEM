#
#                This source code is part of
#
#                          HelFEM
#                             -
# Finite element methods for electronic structure calculations on small systems
#
# Written by Susi Lehtola, 2018-
# Copyright (c) 2018- Susi Lehtola
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# Code to generate sources for arbitrary order derivatives of LIP
# basis functions.

kahan = False
maxorder = 10

print('''/* This file is autogenerated with generate_lip_code.py */
#include "LIPBasis.h"
#include <cfloat>

namespace helfem {
  namespace polynomial_basis {
''')

def get_fname(order):
    fname = 'f'
    if order == 1:
        fname = 'df'
    if order > 1:
        fname = 'd{}f'.format(order)
    return fname

print('void LIPBasis::eval_prim_dnf(const arma::vec & x, arma::mat & dnf, int n, double element_length) const {')
print('switch(n) {')

for order in range(0,maxorder):
    fname='dnf'
    print('case({}):'.format(order))
    print('{')

    print('// Allocate memory\n{}.zeros(x.n_elem, x0.n_elem);'.format(fname))

    print('// Loop over points\nfor(size_t ix=0; ix<x.n_elem; ix++) {')
    print('// Loop over polynomials\nfor(size_t fi=0; fi<x0.n_elem; fi++) {')
    if order>0:
        if kahan:
            print('// For Kahan summation')
            print('double s=0.0, s2=0.0, t;')
        else:
            print('double el=0.0;')

    # Derivative loops
    factor = 1
    for ider in range(1,order+1):
        print('// Derivative {0} acting on index\nfor(size_t d{0}=0; d{0}<{1}; d{0}++) {{'.format(ider, 'x0.n_elem' if ider==1 else 'd{}'.format(ider-1)))

        # Skip these terms
        check_terms = ['fi']
        for term in check_terms:
            print('if(d{0} == {1}) continue;'.format(ider, term))

        # The speedup factor grows factorially(!)
        factor *= ider

    # Now do the product
    print('// Form the LIP product\ndouble {}val = 1.0;'.format(fname))
    print('for(size_t ip=0; ip<x0.n_elem; ip++) {')
    print('// Skip terms which have been acted upon by a derivative')
    check_terms = ['d{}'.format(o) for o in range(1,order+1)]
    check_terms.append('fi')
    for term in check_terms:
        print('if(ip == {}) continue;'.format(term))
    print('{}val *= (x(ix)-x0(ip))/(x0(fi)-x0(ip));'.format(fname))
    print('}')

    # Form the divider
    div_terms = ['(x0(fi)-x0(d{}))'.format(o) for o in range(1,order+1)]
    if len(div_terms)>0:
        print('// Apply derivative denominators\n{}val /= '.format(fname) + '*'.join(div_terms) + ';')

    print('// Store the computed value')
    if order>0:
        if kahan:
            print('// Kahan summation algorithm')
            print('s2 = s2 + {0}val;'.format(fname))
            print('t = s + s2;')
            print('s2 = (s-t) + s2;')
            print('s = t;')
            for ider in range(1,order+1):
                print('}')
            print('{0}(ix,fi) = {1}s;'.format(fname, '{}*'.format(factor) if factor>1 else ''))
            #print('printf("{0}(%i,%i) = %e error %e\\n",ix,fi,s,s2);'.format(fname))
        else:
            print('el += {0}val;'.format(fname))
            for ider in range(1,order+1):
                print('}')
            print('{0}(ix,fi) = {1}el;'.format(fname, '{}*'.format(factor) if factor>1 else ''))
    else:
        print('{0}(ix,fi) = {1}{0}val;'.format(fname, '{}*'.format(factor) if factor>1 else ''))
    # End segment
    print('}\n}\n}')
    print('break;')
print('default:\nstd::ostringstream oss;\noss << n << "th derivatives not implemented!\\n";\nthrow std::logic_error(oss.str());')
print('}\n}')

# End header
print('''}
}
''')
