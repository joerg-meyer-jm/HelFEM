/* This file is autogenerated with generate_lip_code.py */
#include "HIPBasis.h"
#include <cfloat>

namespace helfem {
  namespace polynomial_basis {

    void HIPBasis::eval_prim_dnf(const arma::vec &x, arma::mat &dnf, int n,
                                 double element_length) const {
      switch (n) {
      case (0): {
        // Allocate memory
        dnf.zeros(x.n_elem, 2 * x0.n_elem);

        // Evaluate LIP basis data
        double dummy_length = 1.0;
        arma::mat flip;
        LIPBasis::eval_prim_dnf(x, flip, 0, dummy_length);
        // Loop over points
        for (size_t ix = 0; ix < x.n_elem; ix++) {
          // Loop over polynomials
          for (size_t fi = 0; fi < x0.n_elem; fi++) {
            /* First function is [1 - 2(x-xi)*lipxi(fi)] [l_i(x)]^2 = f1 * f2.
               Second function is (x-xi) * [l_i(x)]^2 = f3 * f2
            */
            double f1 = 1.0 - 2.0 * (x(ix) - x0(fi)) * lipxi(fi);

            double f3 = x(ix) - x0(fi);

            double f2 = flip(ix, fi) * flip(ix, fi);
            dnf(ix, 2 * fi) = f1 * f2;
            dnf(ix, 2 * fi + 1) = f3 * f2 * element_length;
          }
        }
      } break;
      case (1): {
        // Allocate memory
        dnf.zeros(x.n_elem, 2 * x0.n_elem);

        // Evaluate LIP basis data
        double dummy_length = 1.0;
        arma::mat flip;
        LIPBasis::eval_prim_dnf(x, flip, 0, dummy_length);
        arma::mat dflip;
        LIPBasis::eval_prim_dnf(x, dflip, 1, dummy_length);
        // Loop over points
        for (size_t ix = 0; ix < x.n_elem; ix++) {
          // Loop over polynomials
          for (size_t fi = 0; fi < x0.n_elem; fi++) {
            /* First function is [1 - 2(x-xi)*lipxi(fi)] [l_i(x)]^2 = f1 * f2.
               Second function is (x-xi) * [l_i(x)]^2 = f3 * f2
            */
            double f1 = 1.0 - 2.0 * (x(ix) - x0(fi)) * lipxi(fi);
            double df1 = -2.0 * lipxi(fi);

            double f3 = x(ix) - x0(fi);
            double df3 = 1;

            double f2 = flip(ix, fi) * flip(ix, fi);
            double df2 = +2 * dflip(ix, fi) * flip(ix, fi);
            dnf(ix, 2 * fi) = 1 * df1 * f2 + f1 * df2;
            dnf(ix, 2 * fi + 1) = (1 * df3 * f2 + f3 * df2) * element_length;
          }
        }
      } break;
      case (2): {
        // Allocate memory
        dnf.zeros(x.n_elem, 2 * x0.n_elem);

        // Evaluate LIP basis data
        double dummy_length = 1.0;
        arma::mat flip;
        LIPBasis::eval_prim_dnf(x, flip, 0, dummy_length);
        arma::mat dflip;
        LIPBasis::eval_prim_dnf(x, dflip, 1, dummy_length);
        arma::mat d2flip;
        LIPBasis::eval_prim_dnf(x, d2flip, 2, dummy_length);
        // Loop over points
        for (size_t ix = 0; ix < x.n_elem; ix++) {
          // Loop over polynomials
          for (size_t fi = 0; fi < x0.n_elem; fi++) {
            /* First function is [1 - 2(x-xi)*lipxi(fi)] [l_i(x)]^2 = f1 * f2.
               Second function is (x-xi) * [l_i(x)]^2 = f3 * f2
            */
            double f1 = 1.0 - 2.0 * (x(ix) - x0(fi)) * lipxi(fi);
            double df1 = -2.0 * lipxi(fi);

            double f3 = x(ix) - x0(fi);
            double df3 = 1;

            double df2 = +2 * dflip(ix, fi) * flip(ix, fi);
            double d2f2 = +2 * d2flip(ix, fi) * flip(ix, fi) +
                          2 * dflip(ix, fi) * dflip(ix, fi);
            dnf(ix, 2 * fi) = 2 * df1 * df2 + f1 * d2f2;
            dnf(ix, 2 * fi + 1) = (2 * df3 * df2 + f3 * d2f2) * element_length;
          }
        }
      } break;
      case (3): {
        // Allocate memory
        dnf.zeros(x.n_elem, 2 * x0.n_elem);

        // Evaluate LIP basis data
        double dummy_length = 1.0;
        arma::mat flip;
        LIPBasis::eval_prim_dnf(x, flip, 0, dummy_length);
        arma::mat dflip;
        LIPBasis::eval_prim_dnf(x, dflip, 1, dummy_length);
        arma::mat d2flip;
        LIPBasis::eval_prim_dnf(x, d2flip, 2, dummy_length);
        arma::mat d3flip;
        LIPBasis::eval_prim_dnf(x, d3flip, 3, dummy_length);
        // Loop over points
        for (size_t ix = 0; ix < x.n_elem; ix++) {
          // Loop over polynomials
          for (size_t fi = 0; fi < x0.n_elem; fi++) {
            /* First function is [1 - 2(x-xi)*lipxi(fi)] [l_i(x)]^2 = f1 * f2.
               Second function is (x-xi) * [l_i(x)]^2 = f3 * f2
            */
            double f1 = 1.0 - 2.0 * (x(ix) - x0(fi)) * lipxi(fi);
            double df1 = -2.0 * lipxi(fi);

            double f3 = x(ix) - x0(fi);
            double df3 = 1;

            double d2f2 = +2 * d2flip(ix, fi) * flip(ix, fi) +
                          2 * dflip(ix, fi) * dflip(ix, fi);
            double d3f2 = +2 * d3flip(ix, fi) * flip(ix, fi) +
                          6 * d2flip(ix, fi) * dflip(ix, fi);
            dnf(ix, 2 * fi) = 3 * df1 * d2f2 + f1 * d3f2;
            dnf(ix, 2 * fi + 1) = (3 * df3 * d2f2 + f3 * d3f2) * element_length;
          }
        }
      } break;
      case (4): {
        // Allocate memory
        dnf.zeros(x.n_elem, 2 * x0.n_elem);

        // Evaluate LIP basis data
        double dummy_length = 1.0;
        arma::mat flip;
        LIPBasis::eval_prim_dnf(x, flip, 0, dummy_length);
        arma::mat dflip;
        LIPBasis::eval_prim_dnf(x, dflip, 1, dummy_length);
        arma::mat d2flip;
        LIPBasis::eval_prim_dnf(x, d2flip, 2, dummy_length);
        arma::mat d3flip;
        LIPBasis::eval_prim_dnf(x, d3flip, 3, dummy_length);
        arma::mat d4flip;
        LIPBasis::eval_prim_dnf(x, d4flip, 4, dummy_length);
        // Loop over points
        for (size_t ix = 0; ix < x.n_elem; ix++) {
          // Loop over polynomials
          for (size_t fi = 0; fi < x0.n_elem; fi++) {
            /* First function is [1 - 2(x-xi)*lipxi(fi)] [l_i(x)]^2 = f1 * f2.
               Second function is (x-xi) * [l_i(x)]^2 = f3 * f2
            */
            double f1 = 1.0 - 2.0 * (x(ix) - x0(fi)) * lipxi(fi);
            double df1 = -2.0 * lipxi(fi);

            double f3 = x(ix) - x0(fi);
            double df3 = 1;

            double d3f2 = +2 * d3flip(ix, fi) * flip(ix, fi) +
                          6 * d2flip(ix, fi) * dflip(ix, fi);
            double d4f2 = +2 * d4flip(ix, fi) * flip(ix, fi) +
                          8 * d3flip(ix, fi) * dflip(ix, fi) +
                          6 * d2flip(ix, fi) * d2flip(ix, fi);
            dnf(ix, 2 * fi) = 4 * df1 * d3f2 + f1 * d4f2;
            dnf(ix, 2 * fi + 1) = (4 * df3 * d3f2 + f3 * d4f2) * element_length;
          }
        }
      } break;
      case (5): {
        // Allocate memory
        dnf.zeros(x.n_elem, 2 * x0.n_elem);

        // Evaluate LIP basis data
        double dummy_length = 1.0;
        arma::mat flip;
        LIPBasis::eval_prim_dnf(x, flip, 0, dummy_length);
        arma::mat dflip;
        LIPBasis::eval_prim_dnf(x, dflip, 1, dummy_length);
        arma::mat d2flip;
        LIPBasis::eval_prim_dnf(x, d2flip, 2, dummy_length);
        arma::mat d3flip;
        LIPBasis::eval_prim_dnf(x, d3flip, 3, dummy_length);
        arma::mat d4flip;
        LIPBasis::eval_prim_dnf(x, d4flip, 4, dummy_length);
        arma::mat d5flip;
        LIPBasis::eval_prim_dnf(x, d5flip, 5, dummy_length);
        // Loop over points
        for (size_t ix = 0; ix < x.n_elem; ix++) {
          // Loop over polynomials
          for (size_t fi = 0; fi < x0.n_elem; fi++) {
            /* First function is [1 - 2(x-xi)*lipxi(fi)] [l_i(x)]^2 = f1 * f2.
               Second function is (x-xi) * [l_i(x)]^2 = f3 * f2
            */
            double f1 = 1.0 - 2.0 * (x(ix) - x0(fi)) * lipxi(fi);
            double df1 = -2.0 * lipxi(fi);

            double f3 = x(ix) - x0(fi);
            double df3 = 1;

            double d4f2 = +2 * d4flip(ix, fi) * flip(ix, fi) +
                          8 * d3flip(ix, fi) * dflip(ix, fi) +
                          6 * d2flip(ix, fi) * d2flip(ix, fi);
            double d5f2 = +2 * d5flip(ix, fi) * flip(ix, fi) +
                          10 * d4flip(ix, fi) * dflip(ix, fi) +
                          20 * d3flip(ix, fi) * d2flip(ix, fi);
            dnf(ix, 2 * fi) = 5 * df1 * d4f2 + f1 * d5f2;
            dnf(ix, 2 * fi + 1) = (5 * df3 * d4f2 + f3 * d5f2) * element_length;
          }
        }
      } break;
      case (6): {
        // Allocate memory
        dnf.zeros(x.n_elem, 2 * x0.n_elem);

        // Evaluate LIP basis data
        double dummy_length = 1.0;
        arma::mat flip;
        LIPBasis::eval_prim_dnf(x, flip, 0, dummy_length);
        arma::mat dflip;
        LIPBasis::eval_prim_dnf(x, dflip, 1, dummy_length);
        arma::mat d2flip;
        LIPBasis::eval_prim_dnf(x, d2flip, 2, dummy_length);
        arma::mat d3flip;
        LIPBasis::eval_prim_dnf(x, d3flip, 3, dummy_length);
        arma::mat d4flip;
        LIPBasis::eval_prim_dnf(x, d4flip, 4, dummy_length);
        arma::mat d5flip;
        LIPBasis::eval_prim_dnf(x, d5flip, 5, dummy_length);
        arma::mat d6flip;
        LIPBasis::eval_prim_dnf(x, d6flip, 6, dummy_length);
        // Loop over points
        for (size_t ix = 0; ix < x.n_elem; ix++) {
          // Loop over polynomials
          for (size_t fi = 0; fi < x0.n_elem; fi++) {
            /* First function is [1 - 2(x-xi)*lipxi(fi)] [l_i(x)]^2 = f1 * f2.
               Second function is (x-xi) * [l_i(x)]^2 = f3 * f2
            */
            double f1 = 1.0 - 2.0 * (x(ix) - x0(fi)) * lipxi(fi);
            double df1 = -2.0 * lipxi(fi);

            double f3 = x(ix) - x0(fi);
            double df3 = 1;

            double d5f2 = +2 * d5flip(ix, fi) * flip(ix, fi) +
                          10 * d4flip(ix, fi) * dflip(ix, fi) +
                          20 * d3flip(ix, fi) * d2flip(ix, fi);
            double d6f2 = +2 * d6flip(ix, fi) * flip(ix, fi) +
                          12 * d5flip(ix, fi) * dflip(ix, fi) +
                          30 * d4flip(ix, fi) * d2flip(ix, fi) +
                          20 * d3flip(ix, fi) * d3flip(ix, fi);
            dnf(ix, 2 * fi) = 6 * df1 * d5f2 + f1 * d6f2;
            dnf(ix, 2 * fi + 1) = (6 * df3 * d5f2 + f3 * d6f2) * element_length;
          }
        }
      } break;
      case (7): {
        // Allocate memory
        dnf.zeros(x.n_elem, 2 * x0.n_elem);

        // Evaluate LIP basis data
        double dummy_length = 1.0;
        arma::mat flip;
        LIPBasis::eval_prim_dnf(x, flip, 0, dummy_length);
        arma::mat dflip;
        LIPBasis::eval_prim_dnf(x, dflip, 1, dummy_length);
        arma::mat d2flip;
        LIPBasis::eval_prim_dnf(x, d2flip, 2, dummy_length);
        arma::mat d3flip;
        LIPBasis::eval_prim_dnf(x, d3flip, 3, dummy_length);
        arma::mat d4flip;
        LIPBasis::eval_prim_dnf(x, d4flip, 4, dummy_length);
        arma::mat d5flip;
        LIPBasis::eval_prim_dnf(x, d5flip, 5, dummy_length);
        arma::mat d6flip;
        LIPBasis::eval_prim_dnf(x, d6flip, 6, dummy_length);
        arma::mat d7flip;
        LIPBasis::eval_prim_dnf(x, d7flip, 7, dummy_length);
        // Loop over points
        for (size_t ix = 0; ix < x.n_elem; ix++) {
          // Loop over polynomials
          for (size_t fi = 0; fi < x0.n_elem; fi++) {
            /* First function is [1 - 2(x-xi)*lipxi(fi)] [l_i(x)]^2 = f1 * f2.
               Second function is (x-xi) * [l_i(x)]^2 = f3 * f2
            */
            double f1 = 1.0 - 2.0 * (x(ix) - x0(fi)) * lipxi(fi);
            double df1 = -2.0 * lipxi(fi);

            double f3 = x(ix) - x0(fi);
            double df3 = 1;

            double d6f2 = +2 * d6flip(ix, fi) * flip(ix, fi) +
                          12 * d5flip(ix, fi) * dflip(ix, fi) +
                          30 * d4flip(ix, fi) * d2flip(ix, fi) +
                          20 * d3flip(ix, fi) * d3flip(ix, fi);
            double d7f2 = +2 * d7flip(ix, fi) * flip(ix, fi) +
                          14 * d6flip(ix, fi) * dflip(ix, fi) +
                          42 * d5flip(ix, fi) * d2flip(ix, fi) +
                          70 * d4flip(ix, fi) * d3flip(ix, fi);
            dnf(ix, 2 * fi) = 7 * df1 * d6f2 + f1 * d7f2;
            dnf(ix, 2 * fi + 1) = (7 * df3 * d6f2 + f3 * d7f2) * element_length;
          }
        }
      } break;
      case (8): {
        // Allocate memory
        dnf.zeros(x.n_elem, 2 * x0.n_elem);

        // Evaluate LIP basis data
        double dummy_length = 1.0;
        arma::mat flip;
        LIPBasis::eval_prim_dnf(x, flip, 0, dummy_length);
        arma::mat dflip;
        LIPBasis::eval_prim_dnf(x, dflip, 1, dummy_length);
        arma::mat d2flip;
        LIPBasis::eval_prim_dnf(x, d2flip, 2, dummy_length);
        arma::mat d3flip;
        LIPBasis::eval_prim_dnf(x, d3flip, 3, dummy_length);
        arma::mat d4flip;
        LIPBasis::eval_prim_dnf(x, d4flip, 4, dummy_length);
        arma::mat d5flip;
        LIPBasis::eval_prim_dnf(x, d5flip, 5, dummy_length);
        arma::mat d6flip;
        LIPBasis::eval_prim_dnf(x, d6flip, 6, dummy_length);
        arma::mat d7flip;
        LIPBasis::eval_prim_dnf(x, d7flip, 7, dummy_length);
        arma::mat d8flip;
        LIPBasis::eval_prim_dnf(x, d8flip, 8, dummy_length);
        // Loop over points
        for (size_t ix = 0; ix < x.n_elem; ix++) {
          // Loop over polynomials
          for (size_t fi = 0; fi < x0.n_elem; fi++) {
            /* First function is [1 - 2(x-xi)*lipxi(fi)] [l_i(x)]^2 = f1 * f2.
               Second function is (x-xi) * [l_i(x)]^2 = f3 * f2
            */
            double f1 = 1.0 - 2.0 * (x(ix) - x0(fi)) * lipxi(fi);
            double df1 = -2.0 * lipxi(fi);

            double f3 = x(ix) - x0(fi);
            double df3 = 1;

            double d7f2 = +2 * d7flip(ix, fi) * flip(ix, fi) +
                          14 * d6flip(ix, fi) * dflip(ix, fi) +
                          42 * d5flip(ix, fi) * d2flip(ix, fi) +
                          70 * d4flip(ix, fi) * d3flip(ix, fi);
            double d8f2 = +2 * d8flip(ix, fi) * flip(ix, fi) +
                          16 * d7flip(ix, fi) * dflip(ix, fi) +
                          56 * d6flip(ix, fi) * d2flip(ix, fi) +
                          112 * d5flip(ix, fi) * d3flip(ix, fi) +
                          70 * d4flip(ix, fi) * d4flip(ix, fi);
            dnf(ix, 2 * fi) = 8 * df1 * d7f2 + f1 * d8f2;
            dnf(ix, 2 * fi + 1) = (8 * df3 * d7f2 + f3 * d8f2) * element_length;
          }
        }
      } break;
      case (9): {
        // Allocate memory
        dnf.zeros(x.n_elem, 2 * x0.n_elem);

        // Evaluate LIP basis data
        double dummy_length = 1.0;
        arma::mat flip;
        LIPBasis::eval_prim_dnf(x, flip, 0, dummy_length);
        arma::mat dflip;
        LIPBasis::eval_prim_dnf(x, dflip, 1, dummy_length);
        arma::mat d2flip;
        LIPBasis::eval_prim_dnf(x, d2flip, 2, dummy_length);
        arma::mat d3flip;
        LIPBasis::eval_prim_dnf(x, d3flip, 3, dummy_length);
        arma::mat d4flip;
        LIPBasis::eval_prim_dnf(x, d4flip, 4, dummy_length);
        arma::mat d5flip;
        LIPBasis::eval_prim_dnf(x, d5flip, 5, dummy_length);
        arma::mat d6flip;
        LIPBasis::eval_prim_dnf(x, d6flip, 6, dummy_length);
        arma::mat d7flip;
        LIPBasis::eval_prim_dnf(x, d7flip, 7, dummy_length);
        arma::mat d8flip;
        LIPBasis::eval_prim_dnf(x, d8flip, 8, dummy_length);
        arma::mat d9flip;
        LIPBasis::eval_prim_dnf(x, d9flip, 9, dummy_length);
        // Loop over points
        for (size_t ix = 0; ix < x.n_elem; ix++) {
          // Loop over polynomials
          for (size_t fi = 0; fi < x0.n_elem; fi++) {
            /* First function is [1 - 2(x-xi)*lipxi(fi)] [l_i(x)]^2 = f1 * f2.
               Second function is (x-xi) * [l_i(x)]^2 = f3 * f2
            */
            double f1 = 1.0 - 2.0 * (x(ix) - x0(fi)) * lipxi(fi);
            double df1 = -2.0 * lipxi(fi);

            double f3 = x(ix) - x0(fi);
            double df3 = 1;

            double d8f2 = +2 * d8flip(ix, fi) * flip(ix, fi) +
                          16 * d7flip(ix, fi) * dflip(ix, fi) +
                          56 * d6flip(ix, fi) * d2flip(ix, fi) +
                          112 * d5flip(ix, fi) * d3flip(ix, fi) +
                          70 * d4flip(ix, fi) * d4flip(ix, fi);
            double d9f2 = +2 * d9flip(ix, fi) * flip(ix, fi) +
                          18 * d8flip(ix, fi) * dflip(ix, fi) +
                          72 * d7flip(ix, fi) * d2flip(ix, fi) +
                          168 * d6flip(ix, fi) * d3flip(ix, fi) +
                          252 * d5flip(ix, fi) * d4flip(ix, fi);
            dnf(ix, 2 * fi) = 9 * df1 * d8f2 + f1 * d9f2;
            dnf(ix, 2 * fi + 1) = (9 * df3 * d8f2 + f3 * d9f2) * element_length;
          }
        }
      } break;
      default:
        std::ostringstream oss;
        oss << n << "th derivatives not implemented!\n";
        throw std::logic_error(oss.str());
      }
    }
  } // namespace polynomial_basis
} // namespace helfem
