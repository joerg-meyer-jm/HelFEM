/*
 *                This source code is part of
 *
 *                          HelFEM
 *                             -
 * Finite element methods for electronic structure calculations on small systems
 *
 * Written by Susi Lehtola, 2018-
 * Copyright (c) 2018- Susi Lehtola
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 */
#include "RegularizedNucleus.h"
#include "chebyshev.h"
#include <cfloat>
#include <cmath>

namespace helfem {
  namespace modelpotential {
    static double phi(double a, double b, double r) {
      double h=-r*std::erf(a*r)-b*std::exp(-std::pow(a*r,2));
      return std::exp(h)/sqrt(M_PI);
    }

    static double normalization_slice(int N, std::function<double(double)> & phif) {
      // Get quadrature rule
      arma::vec x, w;
      chebyshev::chebyshev(N,x,w);

      // Evaluate normalization by adaptive quadrature
      double h = 1e-1; // Slice size
      // Integrand
      arma::vec f(N);

      double norm=0.0;
      size_t islice=0;
      while(true) {
        // Integration limits
        double r_middle = (islice+0.5)*h;
        // Compute function
        for(int i=0;i<N;i++) {
          double r = r_middle + 0.5*x(i)*h;
          f(i) = r*phif(r);
        }
        // Do quadrature
        double slice = 2.0*h*M_PI*arma::dot(arma::square(f),w);
        norm += slice;
        if(slice == 0.0) {
          //printf("No contribution at r_middle = %e\n",r_middle);
          break;
        }
        islice++;
      }

      return norm;
    }

    static double normalization_chebyshev(int N, std::function<double(double)> & phif) {
      // Get quadrature rule
      arma::vec r, wr;
      chebyshev::radial_chebyshev(N,r,wr);

      // Integrand
      arma::vec f(N);
      for(int i=0;i<N;i++) {
        f(i) = r(i)*phif(r(i));
      }

      return 4.0*M_PI*arma::dot(arma::square(f),wr);
    }

    static double normalization(int N, std::function<double(double)> & phif) {
      return normalization_chebyshev(N, phif);
      //return normalization_slice(N, phif);
    }

    static double phi_normalization(double a, double b, int N) {
      std::function<double(double)> phif = [a,b](double r) {return phi(a,b,r);};
      return normalization(N,phif);
    }

    static double h_normalization(int N) {
      std::function<double(double)> phif = [](double r) {return exp(-r)/sqrt(M_PI);};
      return normalization(N,phif);
    }

    static double find_b(double a, int N) {
      // Find b by bracketing; we want the normalization to be
      const double target=1.0;

      // The normalization behaves non-linearly in b, so we need to
      // first bracket the location of the targeted value with a brute
      // force search
      size_t Npts=1000;
      arma::mat norm(Npts,2);
      norm.col(0) = arma::logspace<arma::vec>(-3,1,Npts);
      for(size_t ip=0; ip<Npts; ip++)
        norm(ip,1) = phi_normalization(a,norm(ip,0),N);
      //norm.save("gyginorm.dat",arma::raw_ascii);

      // Find the value that is closest to the target
      arma::vec dnorm(arma::abs(norm.col(1)-target));
      arma::uword idx;
      dnorm.min(idx);

      double b_right=norm(idx+1,0);
      if(phi_normalization(a,b_right,N) > target)
        throw std::logic_error("Could not right bracket normalized wf!\n");
      double b_left=norm(idx-1,0);
      if(phi_normalization(a,b_left,N) < target)
        throw std::logic_error("Could not left bracket normalized wf!\n");

      //printf("bleft = %e normleft = %e bright = %e normright = %e\n", b_left, phi_normalization(a,b_left,N), b_right, phi_normalization(a,b_right,N));
      double b_middle;
      while(true) {
        b_middle = (b_left+b_right)/2;
        double norm = phi_normalization(a,b_middle, N);
        //printf("Normalization for b=%e is %e, difference from target %e\n",b_middle,norm, norm-target);
        if(norm == target || std::abs(b_right-b_left) <= 10*DBL_EPSILON*b_middle) {
          break;
        } else if(norm > target) {
          b_left = b_middle;
        } else {
          b_right = b_middle;
        }
      }

      return b_middle;
    }

    RegularizedNucleus::RegularizedNucleus(int Z_, double a_) : Z(Z_) {
      // a and b are initialized by set_a
      set_a(a_);
    }

    RegularizedNucleus::~RegularizedNucleus() {
    }

    /* Autogenerated C code from Maple with the input

       with(CodeGeneration);
       h:=r->-r*erf(a*r)-b*exp(-a^2*r^2);
       phi:=r->1/sqrt(Pi)*exp(h(r));
       V:=r->expand(simplify(-1/2 + 1/(2*phi(r)*r)*diff(r*phi(r),r,r)));
       (* Analytic expression *)
       C(V(r), declare = [r::numeric], optimize);

       (* Taylor series at r=0 *)
       p:=r->simplify(convert(series(V(r),r=0,8),polynom));
       C(p(r), declare = [r::numeric], optimize);
    */

    static const double V_analytic(double a, double b, double r) {
      double t1 = a * a;
      double t3 = r * r;
      double t5 = std::exp(t3 * t1);
      double t6 = 0.1e1 / t5;
      double t8 = std::erf(a * r);
      double t13 = std::sqrt(M_PI);
      double t14 = 0.1e1 / t13;
      double t20 = t14 * t3;
      double t21 = t1 * a;
      double t28 = t1 * t1;
      double t29 = t28 * t3;
      double t36 = t5 * t5;
      double t37 = 0.1e1 / t36;
      double t38 = b * b;
      double t51 = t8 * t8;
      return -0.2e1 * b * t8 * t6 * t1 * r + 0.2e1 * t8 * t6 * a * t14 * r + 0.2e1 * t6 * t21 * t20 - 0.4e1 * t6 * a * t14 - 0.2e1 * b * t6 * t29 + 0.3e1 * b * t6 * t1 + 0.2e1 * t38 * t37 * t29 - 0.4e1 * b * t37 * t21 * t20 + 0.2e1 * t37 * t1 / M_PI * t3 + t51 / 0.2e1 - 0.1e1 / 0.2e1 - t8 / r;
    }

    static const double V_taylor(double a, double b, double r) {
      double t1 = r * r;
      double t2 = t1 * t1;
      double t3 = t2 * t1;
      double t6 = a * a;
      double t7 = t6 * t6;
      double t8 = t7 * t7;
      double t13 = t7 * t6;
      double t24 = std::sqrt(M_PI);
      double t25 = t24 * M_PI;
      return 0.4e1 / t25 * (t25 * (-0.1e1 / 0.8e1 + t8 * (b - 0.3e1 / 0.8e1) * t3 * b - t13 * b * (b - 0.7e1 / 0.8e1) * t2 + t7 * (b - 0.5e1 / 0.2e1) * b * t1 / 0.2e1 + 0.3e1 / 0.4e1 * b * t6) - 0.44e2 / 0.15e2 * a * (t24 * (-0.47e2 / 0.66e2 * t3 * t7 * a + 0.10e2 / 0.11e2 * t2 * t6 * a - 0.15e2 / 0.22e2 * t1 * a) + (0.45e2 / 0.88e2 + t13 * (b - 0.45e2 / 0.308e3) * t3 - 0.25e2 / 0.22e2 * t7 * t2 * (b - 0.63e2 / 0.200e3) + 0.15e2 / 0.22e2 * t6 * (b - 0.5e1 / 0.6e1) * t1) * M_PI));
    }

    double RegularizedNucleus::V(double r) const {
      /* Gygi eq. 18: V(Z,r) = Z^2 V(1, Zr) */
      double Zr=Z*r;
      double val;
      if(Zr <= std::cbrt(DBL_EPSILON)) {
        val=modelpotential::V_taylor(a,b,Zr);
        //printf("Zr= %e taylor %e analytic %e diff %e\n",Zr,val,modelpotential::V_analytic(a,b,Zr),val-modelpotential::V_analytic(a,b,Zr));
      } else {
        val=modelpotential::V_analytic(a,b,Zr);
      }
      return std::pow(Z,2)*val;
    }

    double RegularizedNucleus::get_a() const {
      return a;
    }

    double RegularizedNucleus::get_b() const {
      return b;
    }

    void RegularizedNucleus::set_a(double a_) {
      a = a_;

      // Number of quadrature points
      int N = 100;
      b = find_b(a,N);
      printf("a = %.15e yields b = %.15e\n",a,b);
    }
  }
}
